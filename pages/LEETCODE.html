<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1"
        />
        <title> Isciuc Iustin - Constantin </title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
            crossorigin="anonymous"
        />
        <link
            rel="stylesheet"
            href="../style.css"
        />
        <link
            rel="icon"
            href="../images/code.svg"
        />
    </head>
    <body>
        <nav class="navbar bg-body-tertiary fixed-top shadow">
            <div class="container-fluid d-flex justify-content-center">
                <span class="navbar-brand mx-auto h1">
                    <b>
                        <a
                            href="../index.html"
                            class="text-reset text-decoration-none"
                            >Isciuc Iustin - Constantin</a
                        >
                    </b>
                </span>
            </div>
        </nav>
        <main>
            <div class="container min-vh-100 py-5">
                <div class="d-flex justify-content-center my-3">
                    <i> These are my solutions to Leetcode 150: </i>
                </div>
                <div class="d-flex justify-content-start my-3">
                    <ul>
                        <p>
                            <b>
                                <a
                                    href="https://leetcode.com/problems/contains-duplicate/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >217. Contains Duplicate</a
                                >
                                <pre>
                                from typing import List
                                class Solution:

                                    def containsDuplicate(self, nums: List[int]) -&gt; bool:
                                        new_set = set();
                                        for i in range(0, len(nums)):
                                            if nums[i] not in new_set:
                                                new_set.add(nums[i])
                                            else:
                                                return True;
                                        return False;
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/valid-anagram/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >242. Valid Anagram</a
                                >
                                <pre>
                                class Solution:
                                def isAnagram(self, s: str, t: str) -> bool:
                                    hash_table = {}
                                    for ch in s:
                                        if ch not in hash_table:
                                            hash_table[ch] = 1
                                        else:
                                            hash_table[ch] = hash_table[ch] + 1

                                    for ch in t:
                                        if ch not in hash_table:
                                            return False
                                        else:
                                            hash_table[ch] = hash_table[ch] - 1

                                    for code in range(ord('a'), ord('z') + 1):
                                        if chr(code) in hash_table and hash_table[chr(code)] != 0:
                                            return False
                                    return True
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/two-sum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >1. Two Sum</a
                                >
                                <pre>
                                from typing import List
                                class Solution:
                                    def twoSum(self, nums: List[int], target: int) -> List[int]:
                                        hash_table = {}
                                        for i in range(0, len(nums)):
                                            remainder = target - nums[i]
                                            if remainder in hash_table.keys():
                                                return [hash_table[remainder], i]
                                            hash_table[nums[i]] = i
                                        return []
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/group-anagrams/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >49. Group Anagrams</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
                                            hash_table = {}
                                            for string in strs:
                                                sorted_str = str(sorted(string))
                                                if sorted_str not in hash_table.keys():
                                                    hash_table[sorted_str] = [string]
                                                else:
                                                    hash_table[sorted_str].append(string)

                                            sol = []

                                            for key in hash_table.keys():
                                                sol.append(hash_table[key])

                                            return sol 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/top-k-frequent-elements/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >347. Top K Frequent Elements</a
                                >
                                <pre>
                                    import heapq
                                    from typing import List

                                    class Solution:
                                        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                                            hash_table = {}
                                            for x in nums:
                                                if x not in hash_table:
                                                    hash_table[x] = 1
                                                else:
                                                    hash_table[x] = hash_table[x] + 1
                                            pq = []

                                            for key in hash_table.keys():
                                                heapq.heappush(pq, (hash_table[key], key))

                                            sol = []

                                            for x in heapq.nlargest(iterable=pq, n=k):
                                                sol.append(x[1])
                                            return sol
                                </pre>
                                Better approach (Bucket Sort)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                                            hash_table = {}
                                            for i in range(0, len(nums)):
                                                if nums[i] not in hash_table:
                                                    hash_table[nums[i]] = 1
                                                else:
                                                    hash_table[nums[i]] = hash_table[nums[i]] + 1
                                    
                                            count = [[] for i in range(0, len(nums) + 1)]
                                    
                                            for key, val in hash_table.items():
                                                count[val].append(key)
                                    
                                            sol = []
                                    
                                            for i in range(len(count) - 1, 0, -1):
                                                for x in count[i]:
                                                    sol.append(x)
                                                    if len(sol) == k:
                                                        return sol                                    
                                </pre>
                                <a
                                    href="https://neetcode.io/problems/string-encode-and-decode"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >String Encode and Decode</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:

                                        def encode(self, strs: List[str]) -> str:
                                            encoded_string = ""
                                            for string in strs:
                                                encoded_string += str(len(string)) + "#" + string
                                            return encoded_string

                                        def decode(self, s: str) -> List[str]:
                                            sol = []
                                            i = 0
                                            while i < len(s):
                                                j = i
                                                while s[j] != '#':
                                                    j += 1

                                                length = int(s[i:j])

                                                sol.append(s[j + 1 : j + 1 + length])

                                                i = j + 1 + length
                                                
                                            return sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/product-of-array-except-self/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >238. Product of Array Except Self</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def productExceptSelf(self, nums: List[int]) -> List[int]:
                                            sol = []
                                            lt = []
                                            rt = []
                                            for i in range(0, len(nums)):
                                                if i == 0:
                                                    lt.append(nums[i])
                                                else:
                                                    lt.append(lt[i - 1] * nums[i])

                                            for i in range(len(nums) - 1, -1, -1):
                                                if i == len(nums) - 1:
                                                    rt.append(nums[i])
                                                else:
                                                    rt.append(rt[len(rt) - 1] * nums[i])

                                            rt.reverse()

                                            for i in range(0, len(nums)):
                                                if i == 0:
                                                    sol.append(rt[i + 1])
                                                elif i == len(nums) - 1:
                                                    sol.append(lt[i - 1])
                                                else:
                                                    sol.append(lt[i - 1] * rt[i + 1])

                                            return sol

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-sudoku/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >36. Valid Sudoku</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def isValidSudoku(self, board: List[List[str]]) -> bool:
                                            
                                            for i in range(0, 9):
                                                sodoku_set = set()
                                                for j in range(0, 9):
                                                    if board[i][j] in sodoku_set:
                                                        return False
                                                    elif board[i][j] != ".":
                                                        print(board[i][j])
                                                        sodoku_set.add(board[i][j])

                                            for j in range(0, 9):
                                                sudoku_set = set()
                                                for i in range(0, 9):
                                                    if board[i][j] in sudoku_set:
                                                        return False
                                                    elif board[i][j] != ".":
                                                        sudoku_set.add(board[i][j])

                                            ist = 0
                                            jst = 0

                                            while True:
                                                sudoku_set = set()

                                                for i in range(ist, ist + 3):
                                                    for j in range(jst, jst + 3):
                                                        if board[i][j] in sudoku_set:
                                                            return False
                                                        elif board[i][j] != ".":
                                                            sudoku_set.add(board[i][j])

                                                jst += 3

                                                if jst == 9:
                                                    jst = 0 
                                                    ist += 3

                                                if ist == 9:
                                                    break

                                            return True
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-consecutive-sequence/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >128. Longest Consecutive Sequence</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def longestConsecutive(self, nums: List[int]) -> int:
                                            if len(nums) == 0:
                                                return 0

                                            nums.sort()
                                            longest = 1
                                            current = 1
                                            for i in range(1, len(nums)):
                                                if nums[i] ==  nums[i - 1] + 1:
                                                    current += 1
                                                elif nums[i] > nums[i - 1] + 1:
                                                    current = 1
                                                if longest < current:
                                                    longest = current

                                            return longest
                                </pre>
                                Better approach (Using Set())
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def longestConsecutive(self, nums: List[int]) -> int:
                                            nSet = set(nums)
                                            longest = 0
                                            current = 0
                                            for x in nums:
                                                if (x - 1) not in nSet:
                                                    current = 1
                                                    while (x + current) in nSet:
                                                        current += 1
                                                    if longest < current:
                                                        longest = current 

                                            return longest
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-parentheses/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >20. Valid Parentheses</a
                                >
                                <pre>
                                    class Solution:
                                    def isValid(self, s: str) -> bool:
                                        st = []
                                        for ch in s:  
                                            top = st[len(st) - 1] if len(st) > 0 else -1
                                            if  ch == '(' or ch == '[' or  ch == '{':
                                                st.append(ch)
                                            elif ch == ')' and top == '(' or ch == ']' and top == '[' or ch == '}' and top == '{':
                                                st.pop()
                                            else:
                                                return False

                                        if len(st) != 0:
                                            return False
                                        return True

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/min-stack/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >155. Min Stack</a
                                >
                                <pre>
                                    class MinStack:

                                    def __init__(self):
                                        self.st = []

                                    def push(self, val: int) -> None:
                                        self.st.append(val)

                                    def pop(self) -> None:
                                        self.st.pop()

                                    def top(self) -> int:
                                        return  self.st[-1] 

                                    def getMin(self) -> int:
                                        minim = self.st[-1]
                                        for x in self.st:
                                            if minim > x:
                                                minim = x
                                        return minim
                                </pre>
                                Better approach (Two Stacks)
                                <pre>
                                    class MinStack:

                                    def __init__(self):
                                        self.st = []
                                        self.min_stack = []

                                    def push(self, val: int) -> None:
                                        self.min_stack.append(min(val, self.min_stack[-1] if len(self.min_stack) > 0 else val))
                                        self.st.append(val)

                                    def pop(self) -> None:
                                        self.st.pop()
                                        self.min_stack.pop()


                                    def top(self) -> int:
                                        return  self.st[-1] 

                                    def getMin(self) -> int:
                                        return self.min_stack[-1]
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >150. Evaluate Reverse Polish Notation</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def evalRPN(self, tokens: List[str]) -> int:
                                            operators = {'+', '-', '*', '/'}
                                            st = []

                                            for t in tokens:
                                                if t in operators:
                                                    s_item = int(st.pop())
                                                    f_item = int(st.pop())
                                                    if t == '+':
                                                        res = f_item + s_item
                                                    elif t == '-':
                                                        res = f_item - s_item
                                                    elif t == '*':
                                                        res = f_item * s_item
                                                    else:
                                                        res = int(f_item / s_item)
                                                    st.append(res)
                                                else:
                                                    st.append(t)

                                            return int(st.pop())
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/generate-parentheses/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >22. Generate Parentheses</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def __init__(self):
                                            self.sol = []
                                    
                                        def isValid(self, s : List[str]) -> bool:
                                            st = []
                                            for p in s:
                                                if p == '(':
                                                    st.append(p)
                                                elif p == ')':
                                                    top = 0 if len(st) == 0 else st[-1]
                                                    if top == '(':
                                                        st.pop()
                                                    else:
                                                        return False
                                            if len(st) > 0:
                                                return False
                                           
                                            return True
                                    
                                        def bkt(self, n : int, s: List[str], index : int) -> None:
                                            par = {'(', ')'}
                                            for p in par:
                                                s[index] = p 
                                                if index == (2 * n - 1) and self.isValid(s) == True:
                                                    self.sol.append(''.join(s))
                                                elif index < (2 * n - 1):
                                                    self.bkt(n, s, index + 1)
                                    
                                        def generateParenthesis(self, n: int) -> List[str]:
                                            s = [0] * 2 * n 
                                            self.bkt(n, s, 0)
                                            return self.sol 
                                    
                                </pre>
                                Better approach
                                <pre>
                                    from typing import List

                                    class Solution:

                                        def __init__(self):
                                            self.stack = []
                                            self.sol = []

                                        def bkt(self, openP: int, closeP: int, n: int) -> None:
                                            if openP == closeP == n:
                                                self.sol.append(''.join(self.stack))
                                                return None

                                            if openP < n:
                                                self.stack.append("(")
                                                self.bkt(openP=openP + 1, closeP=closeP, n=n)
                                                self.stack.pop()

                                            if closeP < openP:
                                                self.stack.append(")")
                                                self.bkt(openP=openP, closeP=closeP + 1, n=n)
                                                self.stack.pop()

                                        def generateParenthesis(self, n: int) -> List[str]:
                                            self.bkt(openP=0, closeP=0, n=n)
                                            return self.sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/daily-temperatures/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >739. Daily Temperatures</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def dailyTemperatures(self, temp: List[int]) -> List[int]:
                                            ans = [0] * len(temp)
                                            st = []

                                            for i in range(0, len(temp)):
                                                while len(st) > 0 and temp[st[-1]] < temp[i]:
                                                    ans[st[-1]] = i - st[-1]
                                                    st.pop()

                                                st.append(i)

                                            return ans
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/car-fleet/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >853. Car Fleet</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
                                            pair = [[p, s] for p, s in zip(position, speed)]
                                            st = []


                                            for p, s in sorted(pair)[::-1]:
                                                st.append((target - p) / s)
                                                if len(st) >= 2 and st[-1] <= st[-2]:
                                                    st.pop()

                                            return len(st)

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >84. Largest Rectangle in Histogram</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def largestRectangleArea(self, heights: List[int]) -> int:
                                            maxArea = 0
                                            st = []

                                            for i, h in enumerate(heights):
                                                start = i 
                                                while len(st) > 0 and st[-1][1] > h:
                                                    index , height = st.pop()
                                                    maxArea = max(maxArea, height * (i - index))
                                                    start = index

                                                st.append((start, h))

                                            for i, h in st:
                                                maxArea = max(maxArea, h * (len(heights) - i))

                                            return maxArea

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-palindrome/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >125. Valid Palindrome</a
                                >
                                <pre>
                                    class Solution:
                                    def isPalindrome(self, s: str) -> bool:
                                        new_s = ""
                                        for c in s:
                                            c = c.lower()
                                            if c >= 'a' and c <= 'z' or c >= '0' and c <= '9':
                                                new_s += c 


                                        i = 0 
                                        j = len(new_s) - 1
                                        while i < j :
                                            if new_s[i] != new_s[j]:
                                                return False

                                            i += 1
                                            j -= 1

                                        return True 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >167. Two Sum II - Input Array Is Sorted</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def twoSum(self, numbers: List[int], target: int) -> List[int]:
                                            i = 0
                                            j = len(numbers) - 1

                                            while i < j:
                                                s = numbers[i] + numbers[j]
                                                if s == target:
                                                    return [i + 1, j + 1]

                                                elif s < target:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return []
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/3sum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >15. 3Sum</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def __init__(self):
                                            self.sol = []

                                        def twoSum(self, nums: List[int], target: int, k: int,i : int, j: int ) -> List[int]:
                                            while i < j:
                                                s = nums[i] + nums[j]
                                                if s < target or i == k:
                                                    i += 1
                                                elif s > target or j == k:
                                                    j -= 1
                                                else:
                                                    cand = [nums[i], nums[j], nums[k]]
                                                    self.sol.append(cand)
                                                    i += 1
                                                    while nums[i] == nums[i - 1] and i < j:
                                                        i += 1

                                            return []

                                        def threeSum(self, nums: List[int]) -> List[List[int]]:
                                            nums.sort()

                                            for k in range(0, len(nums) - 2):
                                                if k > 0 and nums[k] == nums[k - 1]:
                                                    continue
                                                print(nums[k])
                                                self.twoSum(nums,(nums[k] * -1), k,  k + 1,len(nums) - 1)

                                            return self.sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/container-with-most-water/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >11. Container With Most Water</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def maxArea(self, height: List[int]) -> int:
                                            max_area = -1
                                            i = 0
                                            j = len(height) - 1
                                            while i < j :
                                                c_area = min(height[i], height[j]) * (j - i)
                                                if c_area > max_area or max_area == -1:
                                                    max_area = c_area

                                                if height[i] < height[j]:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return max_area

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/trapping-rain-water/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >42. Trapping Rain Water</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def trap(self, h: List[int]) -> int:
                                            diff = [0] * len(h)
                                            maxim = 0

                                            for i in range(0, len(h)):
                                                if maxim < h[i]:
                                                    maxim = h[i]
                                                    diff[i] = 0
                                                else:
                                                    diff[i] = maxim - h[i]

                                            w = 0
                                            maxim = 0

                                            for i in range(len(h) - 1, -1, -1):
                                                if maxim < h[i]:
                                                    maxim = h[i]
                                                else:
                                                    diff[i] = min(diff[i], maxim - h[i])
                                                    w += diff[i]

                                            return w
                                </pre>
                                Better approach (Two Pointers)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def trap(self, h: List[int]) -> int:
                                            i = 0
                                            j = len(h) - 1
                                            w = 0
                                            maxL = 0
                                            maxR = 0

                                            while i < j:
                                                if maxL < h[i]:
                                                    maxL = h[i]

                                                if maxR < h[j]:
                                                    maxR = h[j]

                                                maxMin = min(maxL, maxR)

                                                if maxMin > h[i]:
                                                    w += maxMin - h[i]

                                                if maxMin > h[j]:
                                                    w += maxMin - h[j]

                                                if maxL < maxR:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return w

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >121. Best Time to Buy and Sell Stock</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def maxProfit(self, p: List[int]) -> int:
                                            i = 0
                                            j = 1
                                            max_profit = 0

                                            while j < len(p):
                                                while p[j] >= p[i]: 
                                                    if max_profit < p[j] - p[i]:
                                                        max_profit = p[j] - p[i]
                                                    j += 1

                                                    if j == len(p):
                                                        break
                                                i = j 
                                                j = i + 1

                                            return max_profit
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >3. Longest Substring Without Repeating
                                    Characters</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def lengthOfLongestSubstring(self, s: str) -> int:
                                            hash_table = {}
                                            i = 0
                                            j = 0
                                            l_s = 0

                                            while j < len(s):
                                            
                                                if s[j] not in hash_table.keys():
                                                    hash_table[s[j]] = j
                                                else:
                                                    i = max(i, hash_table[s[j]] + 1)
                                                    hash_table[s[j]] = j

                                                l_s = max(l_s, j - i + 1)
                                                j += 1

                                            return l_s

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-repeating-character-replacement/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >424. Longest Repeating Character
                                    Replacement</a
                                >
                                <pre>
                                    class Solution:
                                    def characterReplacement(self, s: str, k: int) -> int:
                                        i = 0
                                        j = 0
                                        max_f = 0
                                        longest = 0
                                        hash_t = {}
                                        while j < len(s):
                                            if s[j] not in hash_t:
                                                hash_t[s[j]] = 1
                                                
                                            else:
                                                hash_t[s[j]] += 1

                                            max_f = max(max_f, hash_t[s[j]])

                                            if (j - i + 1) - max_f <= k:
                                                longest = max(longest, (j - i + 1))
                                            else:
                                                hash_t[s[i]] -= 1
                                                i += 1

                                            j += 1

                                        return longest
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/permutation-in-string/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >567. Permutation in String</a
                                >
                                <pre>
                                from typing import List
                                class Solution:
                                    def checkInclusion(self, s1: str, s2: str) -> bool:
                                        if len(s2) < len(s1):
                                            return False
                                        hash_s1 = {}
                                        hash_s2 = {}

                                        for k in range(ord('a'), ord('z') + 1):
                                            c = chr(k)
                                            hash_s1[c] = 0
                                            hash_s2[c] = 0


                                        for c in s1:
                                            hash_s1[c] += 1

                                        i = 0
                                        j = len(s1) -  1

                                        for x in range(i, j):
                                            hash_s2[s2[x]] += 1


                                        while j < len(s2):
                                            hash_s2[s2[j]] += 1

                                            ok = True

                                            for k in range(ord('a'), ord('z') + 1):
                                                c = chr(k)

                                                if (c in hash_s1) != (c in hash_s2):
                                                    ok = False

                                                if (c in hash_s1 ) and ( c in hash_s2):
                                                    if hash_s1[c] != hash_s2[c]:
                                                        ok = False

                                            if ok == True:
                                                return True

                                            hash_s2[s2[i]] -= 1

                                            i += 1
                                            j += 1

                                        return False

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/minimum-window-substring/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >76. Minimum Window Substring</a
                                >
                                <pre>
                                    class Solution:
                                    def minWindow(self, s: str, t: str) -> str:
                                        if t == "":
                                            return ""

                                        countT, window = {}, {}

                                        for c in t:
                                            countT[c] = 1 + countT.get(c, 0)

                                        have, need = 0, len(countT)

                                        res, resLen = [-1, -1], float("infinity")

                                        l = 0

                                        for r in range(len(s)):
                                            c = s[r]    

                                            window[c] = 1 + window.get(c, 0)

                                            if c in countT and window[c] == countT[c]:
                                                have += 1

                                        

                                            while have == need:
                                                if (r - l + 1) < resLen:
                                                    res = [l, r]
                                                    resLen = (r - l + 1)
                                                
                                                window[s[l]] -= 1

                                                if s[l] in countT and window[s[l]] < countT[s[l]]:
                                                    have -= 1 
                                                l += 1

                                        l, r = res 

                                        return s[l : r + 1] if resLen != float("infinity") else ""
                                </pre>
                            </b>
                        </p>
                    </ul>
                </div>
            </div>
        </main>
    </body>
    <footer>
        <nav class="navbar bg-body-tertiary sticky-bottom">
            <div class="container-fluid d-flex justify-content-center">
                <p>
                    <b>
                        <i>Better Than Yesterday</i>
                    </b>
                </p>
            </div>
        </nav>
    </footer>
</html>
