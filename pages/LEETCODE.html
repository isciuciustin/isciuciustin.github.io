<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1"
        />
        <title> Isciuc Iustin - Constantin </title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
            crossorigin="anonymous"
        />
        <link
            rel="stylesheet"
            href="../style.css"
        />
        <link
            rel="icon"
            href="../images/code.svg"
        />
    </head>
    <body>
        <nav class="navbar bg-body-tertiary fixed-top shadow">
            <div class="container-fluid d-flex justify-content-center">
                <span class="navbar-brand mx-auto h1">
                    <b>
                        <a
                            href="../index.html"
                            class="text-reset text-decoration-none"
                            >Isciuc Iustin - Constantin</a
                        >
                    </b>
                </span>
            </div>
        </nav>
        <main>
            <div class="container min-vh-100 py-5">
                <div class="d-flex justify-content-center my-3">
                    <i> These are my solutions to Leetcode 150: </i>
                </div>
                <div class="d-flex justify-content-start my-3">
                    <ul>
                        <p>
                            <b>
                                <a
                                    href="https://leetcode.com/problems/contains-duplicate/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >217. Contains Duplicate</a
                                >
                                <pre>
                                from typing import List
                                class Solution:

                                    def containsDuplicate(self, nums: List[int]) -&gt; bool:
                                        new_set = set();
                                        for i in range(0, len(nums)):
                                            if nums[i] not in new_set:
                                                new_set.add(nums[i])
                                            else:
                                                return True;
                                        return False;
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/valid-anagram/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >242. Valid Anagram</a
                                >
                                <pre>
                                class Solution:
                                def isAnagram(self, s: str, t: str) -> bool:
                                    hash_table = {}
                                    for ch in s:
                                        if ch not in hash_table:
                                            hash_table[ch] = 1
                                        else:
                                            hash_table[ch] = hash_table[ch] + 1

                                    for ch in t:
                                        if ch not in hash_table:
                                            return False
                                        else:
                                            hash_table[ch] = hash_table[ch] - 1

                                    for code in range(ord('a'), ord('z') + 1):
                                        if chr(code) in hash_table and hash_table[chr(code)] != 0:
                                            return False
                                    return True
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/two-sum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >1. Two Sum</a
                                >
                                <pre>
                                from typing import List
                                class Solution:
                                    def twoSum(self, nums: List[int], target: int) -> List[int]:
                                        hash_table = {}
                                        for i in range(0, len(nums)):
                                            remainder = target - nums[i]
                                            if remainder in hash_table.keys():
                                                return [hash_table[remainder], i]
                                            hash_table[nums[i]] = i
                                        return []
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/group-anagrams/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >49. Group Anagrams</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
                                            hash_table = {}
                                            for string in strs:
                                                sorted_str = str(sorted(string))
                                                if sorted_str not in hash_table.keys():
                                                    hash_table[sorted_str] = [string]
                                                else:
                                                    hash_table[sorted_str].append(string)

                                            sol = []

                                            for key in hash_table.keys():
                                                sol.append(hash_table[key])

                                            return sol 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/top-k-frequent-elements/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >347. Top K Frequent Elements</a
                                >
                                <pre>
                                    import heapq
                                    from typing import List

                                    class Solution:
                                        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                                            hash_table = {}
                                            for x in nums:
                                                if x not in hash_table:
                                                    hash_table[x] = 1
                                                else:
                                                    hash_table[x] = hash_table[x] + 1
                                            pq = []

                                            for key in hash_table.keys():
                                                heapq.heappush(pq, (hash_table[key], key))

                                            sol = []

                                            for x in heapq.nlargest(iterable=pq, n=k):
                                                sol.append(x[1])
                                            return sol
                                </pre>
                                Better approach (Bucket Sort)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                                            hash_table = {}
                                            for i in range(0, len(nums)):
                                                if nums[i] not in hash_table:
                                                    hash_table[nums[i]] = 1
                                                else:
                                                    hash_table[nums[i]] = hash_table[nums[i]] + 1
                                    
                                            count = [[] for i in range(0, len(nums) + 1)]
                                    
                                            for key, val in hash_table.items():
                                                count[val].append(key)
                                    
                                            sol = []
                                    
                                            for i in range(len(count) - 1, 0, -1):
                                                for x in count[i]:
                                                    sol.append(x)
                                                    if len(sol) == k:
                                                        return sol                                    
                                </pre>
                                <a
                                    href="https://neetcode.io/problems/string-encode-and-decode"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >String Encode and Decode</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:

                                        def encode(self, strs: List[str]) -> str:
                                            encoded_string = ""
                                            for string in strs:
                                                encoded_string += str(len(string)) + "#" + string
                                            return encoded_string

                                        def decode(self, s: str) -> List[str]:
                                            sol = []
                                            i = 0
                                            while i < len(s):
                                                j = i
                                                while s[j] != '#':
                                                    j += 1

                                                length = int(s[i:j])

                                                sol.append(s[j + 1 : j + 1 + length])

                                                i = j + 1 + length
                                                
                                            return sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/product-of-array-except-self/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >238. Product of Array Except Self</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def productExceptSelf(self, nums: List[int]) -> List[int]:
                                            sol = []
                                            lt = []
                                            rt = []
                                            for i in range(0, len(nums)):
                                                if i == 0:
                                                    lt.append(nums[i])
                                                else:
                                                    lt.append(lt[i - 1] * nums[i])

                                            for i in range(len(nums) - 1, -1, -1):
                                                if i == len(nums) - 1:
                                                    rt.append(nums[i])
                                                else:
                                                    rt.append(rt[len(rt) - 1] * nums[i])

                                            rt.reverse()

                                            for i in range(0, len(nums)):
                                                if i == 0:
                                                    sol.append(rt[i + 1])
                                                elif i == len(nums) - 1:
                                                    sol.append(lt[i - 1])
                                                else:
                                                    sol.append(lt[i - 1] * rt[i + 1])

                                            return sol

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-sudoku/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >36. Valid Sudoku</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def isValidSudoku(self, board: List[List[str]]) -> bool:
                                            
                                            for i in range(0, 9):
                                                sodoku_set = set()
                                                for j in range(0, 9):
                                                    if board[i][j] in sodoku_set:
                                                        return False
                                                    elif board[i][j] != ".":
                                                        print(board[i][j])
                                                        sodoku_set.add(board[i][j])

                                            for j in range(0, 9):
                                                sudoku_set = set()
                                                for i in range(0, 9):
                                                    if board[i][j] in sudoku_set:
                                                        return False
                                                    elif board[i][j] != ".":
                                                        sudoku_set.add(board[i][j])

                                            ist = 0
                                            jst = 0

                                            while True:
                                                sudoku_set = set()

                                                for i in range(ist, ist + 3):
                                                    for j in range(jst, jst + 3):
                                                        if board[i][j] in sudoku_set:
                                                            return False
                                                        elif board[i][j] != ".":
                                                            sudoku_set.add(board[i][j])

                                                jst += 3

                                                if jst == 9:
                                                    jst = 0 
                                                    ist += 3

                                                if ist == 9:
                                                    break

                                            return True
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-consecutive-sequence/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >128. Longest Consecutive Sequence</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def longestConsecutive(self, nums: List[int]) -> int:
                                            if len(nums) == 0:
                                                return 0

                                            nums.sort()
                                            longest = 1
                                            current = 1
                                            for i in range(1, len(nums)):
                                                if nums[i] ==  nums[i - 1] + 1:
                                                    current += 1
                                                elif nums[i] > nums[i - 1] + 1:
                                                    current = 1
                                                if longest < current:
                                                    longest = current

                                            return longest
                                </pre>
                                Better approach (Using Set())
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def longestConsecutive(self, nums: List[int]) -> int:
                                            nSet = set(nums)
                                            longest = 0
                                            current = 0
                                            for x in nums:
                                                if (x - 1) not in nSet:
                                                    current = 1
                                                    while (x + current) in nSet:
                                                        current += 1
                                                    if longest < current:
                                                        longest = current 

                                            return longest
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-parentheses/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >20. Valid Parentheses</a
                                >
                                <pre>
                                    class Solution:
                                    def isValid(self, s: str) -> bool:
                                        st = []
                                        for ch in s:  
                                            top = st[len(st) - 1] if len(st) > 0 else -1
                                            if  ch == '(' or ch == '[' or  ch == '{':
                                                st.append(ch)
                                            elif ch == ')' and top == '(' or ch == ']' and top == '[' or ch == '}' and top == '{':
                                                st.pop()
                                            else:
                                                return False

                                        if len(st) != 0:
                                            return False
                                        return True

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/min-stack/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >155. Min Stack</a
                                >
                                <pre>
                                    class MinStack:

                                    def __init__(self):
                                        self.st = []

                                    def push(self, val: int) -> None:
                                        self.st.append(val)

                                    def pop(self) -> None:
                                        self.st.pop()

                                    def top(self) -> int:
                                        return  self.st[-1] 

                                    def getMin(self) -> int:
                                        minim = self.st[-1]
                                        for x in self.st:
                                            if minim > x:
                                                minim = x
                                        return minim
                                </pre>
                                Better approach (Two Stacks)
                                <pre>
                                    class MinStack:

                                    def __init__(self):
                                        self.st = []
                                        self.min_stack = []

                                    def push(self, val: int) -> None:
                                        self.min_stack.append(min(val, self.min_stack[-1] if len(self.min_stack) > 0 else val))
                                        self.st.append(val)

                                    def pop(self) -> None:
                                        self.st.pop()
                                        self.min_stack.pop()


                                    def top(self) -> int:
                                        return  self.st[-1] 

                                    def getMin(self) -> int:
                                        return self.min_stack[-1]
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >150. Evaluate Reverse Polish Notation</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def evalRPN(self, tokens: List[str]) -> int:
                                            operators = {'+', '-', '*', '/'}
                                            st = []

                                            for t in tokens:
                                                if t in operators:
                                                    s_item = int(st.pop())
                                                    f_item = int(st.pop())
                                                    if t == '+':
                                                        res = f_item + s_item
                                                    elif t == '-':
                                                        res = f_item - s_item
                                                    elif t == '*':
                                                        res = f_item * s_item
                                                    else:
                                                        res = int(f_item / s_item)
                                                    st.append(res)
                                                else:
                                                    st.append(t)

                                            return int(st.pop())
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/generate-parentheses/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >22. Generate Parentheses</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def __init__(self):
                                            self.sol = []
                                    
                                        def isValid(self, s : List[str]) -> bool:
                                            st = []
                                            for p in s:
                                                if p == '(':
                                                    st.append(p)
                                                elif p == ')':
                                                    top = 0 if len(st) == 0 else st[-1]
                                                    if top == '(':
                                                        st.pop()
                                                    else:
                                                        return False
                                            if len(st) > 0:
                                                return False
                                           
                                            return True
                                    
                                        def bkt(self, n : int, s: List[str], index : int) -> None:
                                            par = {'(', ')'}
                                            for p in par:
                                                s[index] = p 
                                                if index == (2 * n - 1) and self.isValid(s) == True:
                                                    self.sol.append(''.join(s))
                                                elif index < (2 * n - 1):
                                                    self.bkt(n, s, index + 1)
                                    
                                        def generateParenthesis(self, n: int) -> List[str]:
                                            s = [0] * 2 * n 
                                            self.bkt(n, s, 0)
                                            return self.sol 
                                    
                                </pre>
                                Better approach
                                <pre>
                                    from typing import List

                                    class Solution:

                                        def __init__(self):
                                            self.stack = []
                                            self.sol = []

                                        def bkt(self, openP: int, closeP: int, n: int) -> None:
                                            if openP == closeP == n:
                                                self.sol.append(''.join(self.stack))
                                                return None

                                            if openP < n:
                                                self.stack.append("(")
                                                self.bkt(openP=openP + 1, closeP=closeP, n=n)
                                                self.stack.pop()

                                            if closeP < openP:
                                                self.stack.append(")")
                                                self.bkt(openP=openP, closeP=closeP + 1, n=n)
                                                self.stack.pop()

                                        def generateParenthesis(self, n: int) -> List[str]:
                                            self.bkt(openP=0, closeP=0, n=n)
                                            return self.sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/daily-temperatures/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >739. Daily Temperatures</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def dailyTemperatures(self, temp: List[int]) -> List[int]:
                                            ans = [0] * len(temp)
                                            st = []

                                            for i in range(0, len(temp)):
                                                while len(st) > 0 and temp[st[-1]] < temp[i]:
                                                    ans[st[-1]] = i - st[-1]
                                                    st.pop()

                                                st.append(i)

                                            return ans
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/car-fleet/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >853. Car Fleet</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
                                            pair = [[p, s] for p, s in zip(position, speed)]
                                            st = []


                                            for p, s in sorted(pair)[::-1]:
                                                st.append((target - p) / s)
                                                if len(st) >= 2 and st[-1] <= st[-2]:
                                                    st.pop()

                                            return len(st)

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >84. Largest Rectangle in Histogram</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def largestRectangleArea(self, heights: List[int]) -> int:
                                            maxArea = 0
                                            st = []

                                            for i, h in enumerate(heights):
                                                start = i 
                                                while len(st) > 0 and st[-1][1] > h:
                                                    index , height = st.pop()
                                                    maxArea = max(maxArea, height * (i - index))
                                                    start = index

                                                st.append((start, h))

                                            for i, h in st:
                                                maxArea = max(maxArea, h * (len(heights) - i))

                                            return maxArea

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-palindrome/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >125. Valid Palindrome</a
                                >
                                <pre>
                                    class Solution:
                                    def isPalindrome(self, s: str) -> bool:
                                        new_s = ""
                                        for c in s:
                                            c = c.lower()
                                            if c >= 'a' and c <= 'z' or c >= '0' and c <= '9':
                                                new_s += c 


                                        i = 0 
                                        j = len(new_s) - 1
                                        while i < j :
                                            if new_s[i] != new_s[j]:
                                                return False

                                            i += 1
                                            j -= 1

                                        return True 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >167. Two Sum II - Input Array Is Sorted</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def twoSum(self, numbers: List[int], target: int) -> List[int]:
                                            i = 0
                                            j = len(numbers) - 1

                                            while i < j:
                                                s = numbers[i] + numbers[j]
                                                if s == target:
                                                    return [i + 1, j + 1]

                                                elif s < target:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return []
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/3sum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >15. 3Sum</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def __init__(self):
                                            self.sol = []

                                        def twoSum(self, nums: List[int], target: int, k: int,i : int, j: int ) -> List[int]:
                                            while i < j:
                                                s = nums[i] + nums[j]
                                                if s < target or i == k:
                                                    i += 1
                                                elif s > target or j == k:
                                                    j -= 1
                                                else:
                                                    cand = [nums[i], nums[j], nums[k]]
                                                    self.sol.append(cand)
                                                    i += 1
                                                    while nums[i] == nums[i - 1] and i < j:
                                                        i += 1

                                            return []

                                        def threeSum(self, nums: List[int]) -> List[List[int]]:
                                            nums.sort()

                                            for k in range(0, len(nums) - 2):
                                                if k > 0 and nums[k] == nums[k - 1]:
                                                    continue
                                                print(nums[k])
                                                self.twoSum(nums,(nums[k] * -1), k,  k + 1,len(nums) - 1)

                                            return self.sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/container-with-most-water/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >11. Container With Most Water</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def maxArea(self, height: List[int]) -> int:
                                            max_area = -1
                                            i = 0
                                            j = len(height) - 1
                                            while i < j :
                                                c_area = min(height[i], height[j]) * (j - i)
                                                if c_area > max_area or max_area == -1:
                                                    max_area = c_area

                                                if height[i] < height[j]:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return max_area

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/trapping-rain-water/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >42. Trapping Rain Water</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def trap(self, h: List[int]) -> int:
                                            diff = [0] * len(h)
                                            maxim = 0

                                            for i in range(0, len(h)):
                                                if maxim < h[i]:
                                                    maxim = h[i]
                                                    diff[i] = 0
                                                else:
                                                    diff[i] = maxim - h[i]

                                            w = 0
                                            maxim = 0

                                            for i in range(len(h) - 1, -1, -1):
                                                if maxim < h[i]:
                                                    maxim = h[i]
                                                else:
                                                    diff[i] = min(diff[i], maxim - h[i])
                                                    w += diff[i]

                                            return w
                                </pre>
                                Better approach (Two Pointers)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def trap(self, h: List[int]) -> int:
                                            i = 0
                                            j = len(h) - 1
                                            w = 0
                                            maxL = 0
                                            maxR = 0

                                            while i < j:
                                                if maxL < h[i]:
                                                    maxL = h[i]

                                                if maxR < h[j]:
                                                    maxR = h[j]

                                                maxMin = min(maxL, maxR)

                                                if maxMin > h[i]:
                                                    w += maxMin - h[i]

                                                if maxMin > h[j]:
                                                    w += maxMin - h[j]

                                                if maxL < maxR:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return w

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >121. Best Time to Buy and Sell Stock</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def maxProfit(self, p: List[int]) -> int:
                                            i = 0
                                            j = 1
                                            max_profit = 0

                                            while j < len(p):
                                                while p[j] >= p[i]: 
                                                    if max_profit < p[j] - p[i]:
                                                        max_profit = p[j] - p[i]
                                                    j += 1

                                                    if j == len(p):
                                                        break
                                                i = j 
                                                j = i + 1

                                            return max_profit
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >3. Longest Substring Without Repeating
                                    Characters</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def lengthOfLongestSubstring(self, s: str) -> int:
                                            hash_table = {}
                                            i = 0
                                            j = 0
                                            l_s = 0

                                            while j < len(s):
                                            
                                                if s[j] not in hash_table.keys():
                                                    hash_table[s[j]] = j
                                                else:
                                                    i = max(i, hash_table[s[j]] + 1)
                                                    hash_table[s[j]] = j

                                                l_s = max(l_s, j - i + 1)
                                                j += 1

                                            return l_s

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-repeating-character-replacement/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >424. Longest Repeating Character
                                    Replacement</a
                                >
                                <pre>
                                    class Solution:
                                    def characterReplacement(self, s: str, k: int) -> int:
                                        i = 0
                                        j = 0
                                        max_f = 0
                                        longest = 0
                                        hash_t = {}
                                        while j < len(s):
                                            if s[j] not in hash_t:
                                                hash_t[s[j]] = 1
                                                
                                            else:
                                                hash_t[s[j]] += 1

                                            max_f = max(max_f, hash_t[s[j]])

                                            if (j - i + 1) - max_f <= k:
                                                longest = max(longest, (j - i + 1))
                                            else:
                                                hash_t[s[i]] -= 1
                                                i += 1

                                            j += 1

                                        return longest
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/permutation-in-string/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >567. Permutation in String</a
                                >
                                <pre>
                                from typing import List
                                class Solution:
                                    def checkInclusion(self, s1: str, s2: str) -> bool:
                                        if len(s2) < len(s1):
                                            return False
                                        hash_s1 = {}
                                        hash_s2 = {}

                                        for k in range(ord('a'), ord('z') + 1):
                                            c = chr(k)
                                            hash_s1[c] = 0
                                            hash_s2[c] = 0


                                        for c in s1:
                                            hash_s1[c] += 1

                                        i = 0
                                        j = len(s1) -  1

                                        for x in range(i, j):
                                            hash_s2[s2[x]] += 1


                                        while j < len(s2):
                                            hash_s2[s2[j]] += 1

                                            ok = True

                                            for k in range(ord('a'), ord('z') + 1):
                                                c = chr(k)

                                                if (c in hash_s1) != (c in hash_s2):
                                                    ok = False

                                                if (c in hash_s1 ) and ( c in hash_s2):
                                                    if hash_s1[c] != hash_s2[c]:
                                                        ok = False

                                            if ok == True:
                                                return True

                                            hash_s2[s2[i]] -= 1

                                            i += 1
                                            j += 1

                                        return False

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/minimum-window-substring/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >76. Minimum Window Substring</a
                                >
                                <pre>
                                    class Solution:
                                        def minWindow(self, s: str, t: str) -> str:
                                            if t == "":
                                                return ""
                                    
                                            l = 0
                                            r = 0
                                    
                                            hash_t, hash_s = {}, {}
                                    
                                            min_seq = float("infinity")
                                    
                                            sl, sr = [-1, -1]
                                    
                                    
                                            for c in t:
                                                hash_t[c] = 1 + hash_t.get(c, 0)
                                    
                                            have = 0
                                            need = len(hash_t)
                                    
                                            while r < len(s):
                                                hash_s[s[r]] = hash_s.get(s[r], 0) + 1
                                    
                                                if s[r] in hash_t and hash_s[s[r]] == hash_t[s[r]]:
                                                    have += 1
                                    
                                                while have == need:
                                                    if min_seq > (r - l + 1):
                                                        min_seq = r - l + 1
                                                        sl = l
                                                        sr = r 
                                    
                                                    hash_s[s[l]] -= 1 
                                    
                                                    if s[l] in hash_t and hash_s[s[l]] < hash_t[s[l]]:
                                                        have -= 1
                                    
                                                    l += 1
                                                r += 1
                                            return s[sl : sr + 1] if min_seq != float("infinity") else ""
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/sliding-window-maximum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >239. Sliding Window Maximum</a
                                >
                                <pre>
                                    from collections import deque
                                    from typing import List


                                    class Solution:
                                        def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
                                            sol = []
                                            dq = deque()

                                            l = 0
                                            r = l + k - 1

                                            for x in range(r + 1):
                                                while len(dq) > 0 and nums[x] > dq[-1]:
                                                    dq.pop()

                                                dq.append(nums[x])
                                            
                                            sol.append(dq[0])

                                            while r < (len(nums) - 1):
                                                if nums[l] == dq[0]:
                                                    dq.popleft()

                                                l += 1

                                                r += 1

                                                while len(dq) > 0 and nums[r] > dq[-1]:
                                                    dq.pop()
                                                dq.append(nums[r])
                                                sol.append(dq[0])

                                            return sol 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/binary-search/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >704. Binary Search</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def search(self, nums: List[int], target: int) -> int:
                                            l = 0
                                            r = len(nums) - 1

                                            while l <= r:
                                                mid = (l + r) // 2 
                                                if nums[mid] == target:
                                                    return mid
                                                elif nums[mid] > target:
                                                    r = mid - 1
                                                else:
                                                    l = mid + 1 

                                            return -1
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/search-a-2d-matrix/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >74. Search a 2D Matrix</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
                                            arr = []

                                            for r in range(len(matrix)):
                                                for c in range(len(matrix[0])):
                                                    arr.append(matrix[r][c])

                                            l = 0 
                                            r = len(arr) - 1

                                            while l <= r:
                                                mid = (l + r) // 2
                                                if arr[mid] == target:
                                                    return True 
                                                elif target > arr[mid]:
                                                    l = mid + 1
                                                else:
                                                    r = mid - 1

                                            return False 
                                </pre>
                                Better approach (No Extra Space)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
                                            ROWS, COLS = len(matrix), len(matrix[0])

                                            bot, top = 0, ROWS - 1 

                                            while bot <= top:
                                                m_row = (bot + top) // 2 
                                                if target > matrix[m_row][-1]:
                                                    bot = m_row + 1 
                                                elif target < matrix[m_row][0]:
                                                    top = m_row - 1 
                                                else:
                                                    break

                                            if bot > top:
                                                return False 

                                            row = (top + bot) // 2 
                                            print(row)
                                            l, r = 0, COLS - 1 

                                            while l <= r: 
                                                m = (l + r) // 2 
                                                print(m)
                                                if target > matrix[row][m]:
                                                    l = m + 1
                                                elif target < matrix[row][m]:
                                                    r = m - 1
                                                else :
                                                    return True 
                                            return False 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/koko-eating-bananas/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >875. Koko Eating Bananas</a
                                >
                                <pre>
                                    import math 
                                    from typing import List
                                    class Solution:
                                        def minEatingSpeed(self, piles: List[int], h: int) -> int:
                                            l = 1
                                            r = max(piles)

                                            sol = float("infinity")

                                            while l <= r:
                                                k = (l + r) // 2
                                                print(k)
                                                h_e = 0

                                                for i in range(len(piles)):
                                                    h_e += math.ceil(piles[i] / k)

                                                if h_e <=  h:
                                                    sol = k 
                                                    r = k - 1
                                                else:
                                                    l = k + 1

                                            return sol

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >153. Find Minimum in Rotated Sorted
                                    Array</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def findMin(self, nums: List[int]) -> int:
                                            res = nums[0]

                                            l, r = 0, len(nums) - 1

                                            while l <= r:
                                                if nums[l] < nums[r]:
                                                    res = min(res, nums[l])
                                                    break

                                                m = (l + r) // 2
                                                res = min(res, nums[m])

                                                if nums[m] >= nums[l]:
                                                    l = m + 1
                                                else:
                                                    r = m - 1
                                            return res 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >33. Search in Rotated Sorted Array</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def search(self, nums: List[int], target: int) -> int:
                                            l, r = 0, len(nums) - 1

                                            while l <= r:
                                                m = (l + r) // 2
                                                if target == nums[m]:
                                                    return m

                                                if nums[l] <= nums[m]:
                                                    if target > nums[m] or target < nums[l]:
                                                        l = m + 1 
                                                    else:
                                                        r = m - 1 
                                                else:
                                                    if target < nums[m] or target > nums[r]:
                                                        r = m - 1
                                                    else:
                                                        l = m + 1

                                            return -1 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/time-based-key-value-store/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >981. Time Based Key-Value Store</a
                                >
                                <pre>
                                    class TimeMap:

                                    def __init__(self):
                                        self.hash = {}

                                    def set(self, key: str, value: str, timestamp: int) -> None:
                                        if key not in self.hash:
                                            self.hash[key] = { "v" : [], "t" : []}

                                        self.hash[key]["v"].append(value)
                                        self.hash[key]["t"].append(timestamp)

                                    def get(self, key: str, timestamp: int) -> str:
                                        if key not in self.hash:
                                            return ""
                                        arr = self.hash[key]["t"]

                                        l , r = 0, len(arr) - 1 
                                        index = float("infinity")
                                        while l <= r:
                                            m = (l + r) // 2 
                                            if arr[m] <= timestamp:
                                                index = m
                                                if arr[m] == timestamp:
                                                    break
                                                else:
                                                    l = m + 1 
                                            else:
                                                r = m - 1
                                        if index != float("infinity"):
                                            return self.hash[key]["v"][index]
                                        return ""
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >4. Median of Two Sorted Arrays</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
                                            A, B = nums1, nums2
                                            total = len(nums1) + len(nums2)
                                            half = total // 2

                                            if len(B) < len(A):
                                                A, B = B, A

                                            l, r = 0, len(A) - 1
                                            while True:
                                                i = (l + r) // 2  
                                                j = half - i - 2  

                                                Aleft = A[i] if i >= 0 else float("-infinity")
                                                Aright = A[i + 1] if (i + 1) < len(A) else float("infinity")
                                                Bleft = B[j] if j >= 0 else float("-infinity")
                                                Bright = B[j + 1] if (j + 1) < len(B) else float("infinity")

                                                if Aleft <= Bright and Bleft <= Aright:
                                                    if total % 2:
                                                        return min(Aright, Bright)
                                                    return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
                                                elif Aleft > Bright:
                                                    r = i - 1
                                                else:
                                                    l = i + 1
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/reverse-linked-list/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >206. Reverse Linked List</a
                                >
                                <br />
                                ITERATIVE APPROACH:
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
                                                current = head;
                                                prev = None;
                                                if current == None:
                                                    return current
                                                while current.next != None:
                                                    next_node = current.next
                                                    current.next = prev
                                                    prev = current
                                                    current = next_node
                                                current.next = prev
                                                return current
                                    </code>
                                </pre>
                                RECURSIVE APPROACH:

                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
                                                def recursive(ll, rl):
                                                    if not ll:
                                                        return rl
                                                    return recursive(ll.next, ListNode(ll.val, rl))
                                                
                                                return recursive(head, None)
                                    </code>
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/merge-two-sorted-lists/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >21. Merge Two Sorted Lists</a
                                >
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def mergeTwoLists(self, list1, list2):
                                                head = None
                                                current = None
                                                
                                                while list1 != None and list2 != None:
                                                    new_node = ListNode()
                                                    if list1.val < list2.val:
                                                        new_node.val = list1.val
                                                        list1 = list1.next
                                                    else:
                                                        new_node.val = list2.val
                                                        list2 = list2.next
                                                    if head == None:
                                                        head = new_node
                                                        current = head
                                                    else:
                                                        current.next = new_node
                                                        current = new_node

                                                if list1 != None:
                                                    if current == None:
                                                        head = list1
                                                    else:
                                                        current.next = list1
                                                if list2 != None:
                                                    if current == None:
                                                        head = list2
                                                    else:
                                                        current.next = list2

                                                current = head
                                                while current != None:
                                                    current = current.next
                                                
                                                return head
                                                
                                    </code>
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/reorder-list/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >143. Reorder List
                                </a>
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next

                                        class Solution:
                                            def reorderList(self, head: Optional[ListNode]) -> None:
                                                """
                                                Do not return anything, modify head in-place instead.
                                                """
                                                # 1 Find the middle and split the list in two segments

                                                slow = head 
                                                fast = head.next

                                                while fast and fast.next:
                                                    slow = slow.next
                                                    fast = fast.next.next

                                                second = slow.next
                                                slow.next = prev = None

                                                # 2 Reverse the second segment

                                                while second:
                                                    tmp = second.next 
                                                    second.next = prev
                                                    prev = second
                                                    second = tmp
                                                
                                                first = head
                                                second = prev

                                                # 3 Merge the two segments

                                                while second:
                                                    tmp1 = first.next
                                                    tmp2 = second.next

                                                    first.next = second
                                                    second.next = tmp1
                                                    first = tmp1
                                                    second = tmp2

                                                #4 Return the reordered list

                                                return head                                    
                                    </code>
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    19. Remove Nth Node From End of List
                                </a>
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
                                                # 1 Initialize two pointers
                                        
                                                p1 = head
                                                p2 = head
                                        
                                                # 2 Move the second pointer n nodes away from the first pointer
                                        
                                                while n > 0:
                                                    p2 = p2.next
                                                    n -= 1
                                                
                                                # 3 Iterate the second pointer until it reaches the end of the list
                                        
                                                while p2 and p2.next:
                                                    p1 = p1.next
                                                    p2 = p2.next
                                                
                                                # 4 Remove the n-th node from the end of the list
                                        
                                                if p2 == None: # if the first node should be removed
                                                    head = head.next
                                                else:
                                                    p1.next = p1.next.next
                                                
                                                # 5 Return the list
                                        
                                                return head
                                    </code> 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/copy-list-with-random-pointer/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    138. Copy List with Random Pointer
                                </a>
                                <pre>
                                    <code>
                                        """
                                        # Definition for a Node.
                                        class Node:
                                            def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
                                                self.val = int(x)
                                                self.next = next
                                                self.random = random
                                        """

                                        class Solution:
                                            def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
                                                # 1 Initialize a hash table where each node of the orginal list 
                                                # will be a key to each node in the copied list

                                                oldToCopy = {None : None}

                                                # 2 Iterate over the list and create a copy of each node with the 
                                                # same value 

                                                cur = head 
                                                while cur:
                                                    copy = Node(cur.val)
                                                    oldToCopy[cur] = copy
                                                    cur = cur.next

                                                # 3 Iterate once again and add the next and random references

                                                cur = head
                                                while cur:
                                                    copy = oldToCopy[cur]
                                                    copy.next = oldToCopy[cur.next]
                                                    copy.random = oldToCopy[cur.random]
                                                    cur = cur.next
                                                
                                                # 4 Return the head of the copied linked list

                                                return oldToCopy[head]
                                                
                                    </code> 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/add-two-numbers/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    2. Add Two Numbers
                                </a>
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
                                                # 1 Initialize the sum variable that will retain the sum of the digits
                                                sum = 0
                                                # 2 Initialize the head of the sum linked list 
                                                # and also the last node of this list

                                                l3 = last = None

                                                # 3 Iterate over the l1 and l2 and add the digits to l3 

                                                while l1 and l2:
                                                    sum += l1.val + l2.val
                                                    if l3 == None:
                                                        l3 = ListNode(sum % 10)
                                                        last = l3 
                                                    else:
                                                        last.next = ListNode(sum % 10)
                                                        last = last.next
                                                    sum = sum // 10
                                                    l1 = l1.next 
                                                    l2 = l2.next
                                                # 4 Iterate over both lists until the finish node

                                                while l1:
                                                    sum += l1.val
                                                    last.next = ListNode(sum % 10)
                                                    last = last.next
                                                    sum = sum // 10
                                                    l1 = l1.next
                                                    
                                                while l2:
                                                    sum += l2.val
                                                    last.next = ListNode(sum % 10)
                                                    last = last.next
                                                    sum = sum // 10
                                                    l2 = l2.next
                                                
                                                # 5 If there is 1 digit remained in the sum 
                                                # add it to the sum list

                                                if sum > 0:
                                                    last.next = ListNode(sum % 10)
                                                    last = last.next
                                                    sum = sum // 10
                                                
                                                # 6 Return the sum as a linked list

                                                return l3
                                    </code> 
                                </pre>

                                <a
                                    href="https://leetcode.com/problems/linked-list-cycle/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    141. Linked List Cycle
                                </a>

                                FIRST APPROACH O(n) memory

                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, x):
                                        #         self.val = x
                                        #         self.next = None

                                        class Solution:
                                            def hasCycle(self, head: ListNode) -> bool:
                                                # 1 Create a hash table in order to retain all the nodes in the 
                                                # linked list 

                                                copy = {}

                                                # 2 Iterate over all the nodes in the list 
                                                # If the same node is reached twice, then we have a cycle
                                                # otherwise not

                                                cur = head 

                                                while cur:
                                                    if cur in copy:
                                                        return True
                                                    else:
                                                        copy[cur] = True
                                                    cur = cur.next

                                                return False 
                                    </code> 
                                </pre>

                                SECOND APPROACH TWO POINTERS : FLOYD'S TURTOISE
                                AND HARE

                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, x):
                                        #         self.val = x
                                        #         self.next = None

                                        class Solution:
                                            def hasCycle(self, head: ListNode) -> bool:
                                                # 1 Initialize two pointers at the head 
                                                slow = fast = head

                                                # 2 Iterate the pointers over the list 
                                                # fast pointer will be iterated twice as fast as 
                                                # the slow pointer

                                                # 3 If there is a cycle in the list, then they 
                                                # will meet at the same position because 
                                                # the difference between them will be decremented 
                                                # by one with each iteration when they 
                                                # are both in the cycle

                                                while fast and fast.next:
                                                    slow = slow.next
                                                    fast = fast.next.next
                                                    if slow == fast:
                                                        return True
                                                return False
        

                                    </code>
                                </pre>

                                <a
                                    href="https://leetcode.com/problems/find-the-duplicate-number/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    287. Find the Duplicate Number
                                </a>
                                <pre>
                                    <code>
                                        class Solution:
                                        def findDuplicate(self, nums: List[int]) -> int:
                                            # 1 Initialize two pointers slow and fast
                                            slow = fast = 0
                                    
                                            # 2 Iterate the fast pointer twice as fast as the slow pointer
                                            # and break when they meet each other 
                                    
                                            while True:
                                                slow = nums[slow]
                                                fast = nums[nums[fast]]
                                                if slow == fast:
                                                    break
                                    
                                            # 3 Initialize a new pointer at the start
                                            slow2 = 0
                                    
                                            # 4 Iterate slow2 and slow until they meet at the start 
                                            # of the cycle which is the duplicate number
                                    
                                            while True:
                                                slow2 = nums[slow2]
                                                slow = nums[slow]
                                                if slow == slow2:
                                                    return slow               
                                    </code>
                                </pre>

                                <a
                                    href="https://leetcode.com/problems/lru-cache/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    146. LRU Cache
                                </a>
                                <pre>
                                    <code>
                                        # Use a doubly linked list that will store at the left side 
                                        # the Least Recently Used key 
                                        # and at the right side the most recently used key

                                        class Node:
                                            def __init__(self, key, value):
                                                self.key = key
                                                self.value = value
                                                self.next = None
                                                self.prev = None
                                            
                                        class LRUCache:

                                            def __init__(self, capacity: int):
                                                self.cap = capacity
                                                self.cache = {}
                                                
                                                self.left = None
                                                self.right = None
                                            
                                            def insert(self, node : Node):
                                                if self.left == None:
                                                    self.left = node
                                                if self.right == None:
                                                    self.right = node
                                                else:
                                                    self.right.next = node
                                                    node.prev = self.right
                                                    self.right = node
                                            
                                            def remove(self, node : Node):
                                                if self.right != node and self.left != node:
                                                    node.prev.next = node.next
                                                    node.next.prev = node.prev
                                                if self.left == node:
                                                    if node.next: 
                                                        node.next.prev = None
                                                    self.left = self.left.next
                                                if self.right == node:
                                                    if node.prev: 
                                                        node.prev.next = None
                                                    self.right = node.prev


                                            def get(self, key: int) -> int:
                                                if key not in self.cache:
                                                    return -1
                                                node = self.cache[key]
                                                self.remove(node)
                                                self.insert(node)
                                                return node.value

                                            def put(self, key: int, value: int) -> None:
                                                if key in self.cache:
                                                    node = self.cache[key]
                                                    node.value = value
                                                    self.remove(node)
                                                    node.next = None
                                                    self.insert(node)
                                                else:         
                                                    self.cap = self.cap - 1
                                                    node = Node(key, value)
                                                    self.insert(node)
                                                    self.cache[key] = node
                                                if self.cap < 0:
                                                    del self.cache[self.left.key]
                                                    self.remove(self.left)
                                                    self.cap += 1
                                    </code> 
                                </pre>

                                <a
                                    href="https://leetcode.com/problems/merge-k-sorted-lists/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                >
                                    23. Merge k Sorted Lists
                                </a>
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
                                                # 1 Iterate the current node on each k linked lists 
                                                # and find the node with the minimum value 
                                                # and iterate the list with the minimum value node 

                                                res = None
                                                last = None
                                                while True:
                                                    min_node = None
                                                    minimum = float("inf")
                                                    it = -1
                                                    for i  in range(0, len(lists)):
                                                        x = lists[i]
                                                        if x is None:
                                                            continue
                                                        if minimum > x.val:
                                                            min_node = x
                                                            minimum = x.val
                                                            it = i
                                                    # if all the lists are finished, 
                                                    # then stop the search
                                                    if min_node == None:  
                                                        break
                                                    if res == None:
                                                        res = min_node
                                                        last = res
                                                    else:
                                                        last.next = min_node
                                                        last = last.next
                                                    lists[it] = lists[it].next
                                                return res
                                    </code> 
                                </pre>
                            </b>
                        </p>
                    </ul>
                </div>
            </div>
        </main>
    </body>
    <footer>
        <nav class="navbar bg-body-tertiary sticky-bottom">
            <div class="container-fluid d-flex justify-content-center">
                <p>
                    <b>
                        <i>Better Than Yesterday</i>
                    </b>
                </p>
            </div>
        </nav>
    </footer>
</html>
