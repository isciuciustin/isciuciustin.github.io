<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1"
        />
        <title> Isciuc Iustin - Constantin </title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
            crossorigin="anonymous"
        />
        <link
            rel="stylesheet"
            href="../style.css"
        />
        <link
            rel="icon"
            href="../images/code.svg"
        />
    </head>
    <body>
        <nav class="navbar bg-body-tertiary fixed-top shadow">
            <div class="container-fluid d-flex justify-content-center">
                <span class="navbar-brand mx-auto h1">
                    <b>
                        <a
                            href="../index.html"
                            class="text-reset text-decoration-none"
                            >Isciuc Iustin - Constantin</a
                        >
                    </b>
                </span>
            </div>
        </nav>
        <main>
            <div class="container min-vh-100 py-5">
                <div class="d-flex justify-content-center my-3">
                    <i> These are my solutions to Leetcode 150: </i>
                </div>
                <div class="d-flex justify-content-start my-3">
                    <ul>
                        <p>
                            <b>
                                <a
                                    href="https://leetcode.com/problems/contains-duplicate/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >217. Contains Duplicate</a
                                >
                                <pre>
                                from typing import List
                                class Solution:

                                    def containsDuplicate(self, nums: List[int]) -&gt; bool:
                                        new_set = set();
                                        for i in range(0, len(nums)):
                                            if nums[i] not in new_set:
                                                new_set.add(nums[i])
                                            else:
                                                return True;
                                        return False;
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/valid-anagram/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >242. Valid Anagram</a
                                >
                                <pre>
                                class Solution:
                                def isAnagram(self, s: str, t: str) -> bool:
                                    hash_table = {}
                                    for ch in s:
                                        if ch not in hash_table:
                                            hash_table[ch] = 1
                                        else:
                                            hash_table[ch] = hash_table[ch] + 1

                                    for ch in t:
                                        if ch not in hash_table:
                                            return False
                                        else:
                                            hash_table[ch] = hash_table[ch] - 1

                                    for code in range(ord('a'), ord('z') + 1):
                                        if chr(code) in hash_table and hash_table[chr(code)] != 0:
                                            return False
                                    return True
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/two-sum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >1. Two Sum</a
                                >
                                <pre>
                                from typing import List
                                class Solution:
                                    def twoSum(self, nums: List[int], target: int) -> List[int]:
                                        hash_table = {}
                                        for i in range(0, len(nums)):
                                            remainder = target - nums[i]
                                            if remainder in hash_table.keys():
                                                return [hash_table[remainder], i]
                                            hash_table[nums[i]] = i
                                        return []
                            </pre
                                >
                                <a
                                    href="https://leetcode.com/problems/group-anagrams/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >49. Group Anagrams</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
                                            hash_table = {}
                                            for string in strs:
                                                sorted_str = str(sorted(string))
                                                if sorted_str not in hash_table.keys():
                                                    hash_table[sorted_str] = [string]
                                                else:
                                                    hash_table[sorted_str].append(string)

                                            sol = []

                                            for key in hash_table.keys():
                                                sol.append(hash_table[key])

                                            return sol 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/top-k-frequent-elements/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >347. Top K Frequent Elements</a
                                >
                                <pre>
                                    import heapq
                                    from typing import List

                                    class Solution:
                                        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                                            hash_table = {}
                                            for x in nums:
                                                if x not in hash_table:
                                                    hash_table[x] = 1
                                                else:
                                                    hash_table[x] = hash_table[x] + 1
                                            pq = []

                                            for key in hash_table.keys():
                                                heapq.heappush(pq, (hash_table[key], key))

                                            sol = []

                                            for x in heapq.nlargest(iterable=pq, n=k):
                                                sol.append(x[1])
                                            return sol
                                </pre>
                                Better approach (Bucket Sort)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                                            hash_table = {}
                                            for i in range(0, len(nums)):
                                                if nums[i] not in hash_table:
                                                    hash_table[nums[i]] = 1
                                                else:
                                                    hash_table[nums[i]] = hash_table[nums[i]] + 1
                                    
                                            count = [[] for i in range(0, len(nums) + 1)]
                                    
                                            for key, val in hash_table.items():
                                                count[val].append(key)
                                    
                                            sol = []
                                    
                                            for i in range(len(count) - 1, 0, -1):
                                                for x in count[i]:
                                                    sol.append(x)
                                                    if len(sol) == k:
                                                        return sol                                    
                                </pre>
                                <a
                                    href="https://neetcode.io/problems/string-encode-and-decode"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >String Encode and Decode</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:

                                        def encode(self, strs: List[str]) -> str:
                                            encoded_string = ""
                                            for string in strs:
                                                encoded_string += str(len(string)) + "#" + string
                                            return encoded_string

                                        def decode(self, s: str) -> List[str]:
                                            sol = []
                                            i = 0
                                            while i < len(s):
                                                j = i
                                                while s[j] != '#':
                                                    j += 1

                                                length = int(s[i:j])

                                                sol.append(s[j + 1 : j + 1 + length])

                                                i = j + 1 + length
                                                
                                            return sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/product-of-array-except-self/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >238. Product of Array Except Self</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def productExceptSelf(self, nums: List[int]) -> List[int]:
                                            sol = []
                                            lt = []
                                            rt = []
                                            for i in range(0, len(nums)):
                                                if i == 0:
                                                    lt.append(nums[i])
                                                else:
                                                    lt.append(lt[i - 1] * nums[i])

                                            for i in range(len(nums) - 1, -1, -1):
                                                if i == len(nums) - 1:
                                                    rt.append(nums[i])
                                                else:
                                                    rt.append(rt[len(rt) - 1] * nums[i])

                                            rt.reverse()

                                            for i in range(0, len(nums)):
                                                if i == 0:
                                                    sol.append(rt[i + 1])
                                                elif i == len(nums) - 1:
                                                    sol.append(lt[i - 1])
                                                else:
                                                    sol.append(lt[i - 1] * rt[i + 1])

                                            return sol

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-sudoku/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >36. Valid Sudoku</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def isValidSudoku(self, board: List[List[str]]) -> bool:
                                            
                                            for i in range(0, 9):
                                                sodoku_set = set()
                                                for j in range(0, 9):
                                                    if board[i][j] in sodoku_set:
                                                        return False
                                                    elif board[i][j] != ".":
                                                        print(board[i][j])
                                                        sodoku_set.add(board[i][j])

                                            for j in range(0, 9):
                                                sudoku_set = set()
                                                for i in range(0, 9):
                                                    if board[i][j] in sudoku_set:
                                                        return False
                                                    elif board[i][j] != ".":
                                                        sudoku_set.add(board[i][j])

                                            ist = 0
                                            jst = 0

                                            while True:
                                                sudoku_set = set()

                                                for i in range(ist, ist + 3):
                                                    for j in range(jst, jst + 3):
                                                        if board[i][j] in sudoku_set:
                                                            return False
                                                        elif board[i][j] != ".":
                                                            sudoku_set.add(board[i][j])

                                                jst += 3

                                                if jst == 9:
                                                    jst = 0 
                                                    ist += 3

                                                if ist == 9:
                                                    break

                                            return True
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-consecutive-sequence/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >128. Longest Consecutive Sequence</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def longestConsecutive(self, nums: List[int]) -> int:
                                            if len(nums) == 0:
                                                return 0

                                            nums.sort()
                                            longest = 1
                                            current = 1
                                            for i in range(1, len(nums)):
                                                if nums[i] ==  nums[i - 1] + 1:
                                                    current += 1
                                                elif nums[i] > nums[i - 1] + 1:
                                                    current = 1
                                                if longest < current:
                                                    longest = current

                                            return longest
                                </pre>
                                Better approach (Using Set())
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def longestConsecutive(self, nums: List[int]) -> int:
                                            nSet = set(nums)
                                            longest = 0
                                            current = 0
                                            for x in nums:
                                                if (x - 1) not in nSet:
                                                    current = 1
                                                    while (x + current) in nSet:
                                                        current += 1
                                                    if longest < current:
                                                        longest = current 

                                            return longest
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-parentheses/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >20. Valid Parentheses</a
                                >
                                <pre>
                                    class Solution:
                                    def isValid(self, s: str) -> bool:
                                        st = []
                                        for ch in s:  
                                            top = st[len(st) - 1] if len(st) > 0 else -1
                                            if  ch == '(' or ch == '[' or  ch == '{':
                                                st.append(ch)
                                            elif ch == ')' and top == '(' or ch == ']' and top == '[' or ch == '}' and top == '{':
                                                st.pop()
                                            else:
                                                return False

                                        if len(st) != 0:
                                            return False
                                        return True

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/min-stack/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >155. Min Stack</a
                                >
                                <pre>
                                    class MinStack:

                                    def __init__(self):
                                        self.st = []

                                    def push(self, val: int) -> None:
                                        self.st.append(val)

                                    def pop(self) -> None:
                                        self.st.pop()

                                    def top(self) -> int:
                                        return  self.st[-1] 

                                    def getMin(self) -> int:
                                        minim = self.st[-1]
                                        for x in self.st:
                                            if minim > x:
                                                minim = x
                                        return minim
                                </pre>
                                Better approach (Two Stacks)
                                <pre>
                                    class MinStack:

                                    def __init__(self):
                                        self.st = []
                                        self.min_stack = []

                                    def push(self, val: int) -> None:
                                        self.min_stack.append(min(val, self.min_stack[-1] if len(self.min_stack) > 0 else val))
                                        self.st.append(val)

                                    def pop(self) -> None:
                                        self.st.pop()
                                        self.min_stack.pop()


                                    def top(self) -> int:
                                        return  self.st[-1] 

                                    def getMin(self) -> int:
                                        return self.min_stack[-1]
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >150. Evaluate Reverse Polish Notation</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def evalRPN(self, tokens: List[str]) -> int:
                                            operators = {'+', '-', '*', '/'}
                                            st = []

                                            for t in tokens:
                                                if t in operators:
                                                    s_item = int(st.pop())
                                                    f_item = int(st.pop())
                                                    if t == '+':
                                                        res = f_item + s_item
                                                    elif t == '-':
                                                        res = f_item - s_item
                                                    elif t == '*':
                                                        res = f_item * s_item
                                                    else:
                                                        res = int(f_item / s_item)
                                                    st.append(res)
                                                else:
                                                    st.append(t)

                                            return int(st.pop())
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/generate-parentheses/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >22. Generate Parentheses</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def __init__(self):
                                            self.sol = []
                                    
                                        def isValid(self, s : List[str]) -> bool:
                                            st = []
                                            for p in s:
                                                if p == '(':
                                                    st.append(p)
                                                elif p == ')':
                                                    top = 0 if len(st) == 0 else st[-1]
                                                    if top == '(':
                                                        st.pop()
                                                    else:
                                                        return False
                                            if len(st) > 0:
                                                return False
                                           
                                            return True
                                    
                                        def bkt(self, n : int, s: List[str], index : int) -> None:
                                            par = {'(', ')'}
                                            for p in par:
                                                s[index] = p 
                                                if index == (2 * n - 1) and self.isValid(s) == True:
                                                    self.sol.append(''.join(s))
                                                elif index < (2 * n - 1):
                                                    self.bkt(n, s, index + 1)
                                    
                                        def generateParenthesis(self, n: int) -> List[str]:
                                            s = [0] * 2 * n 
                                            self.bkt(n, s, 0)
                                            return self.sol 
                                    
                                </pre>
                                Better approach
                                <pre>
                                    from typing import List

                                    class Solution:

                                        def __init__(self):
                                            self.stack = []
                                            self.sol = []

                                        def bkt(self, openP: int, closeP: int, n: int) -> None:
                                            if openP == closeP == n:
                                                self.sol.append(''.join(self.stack))
                                                return None

                                            if openP < n:
                                                self.stack.append("(")
                                                self.bkt(openP=openP + 1, closeP=closeP, n=n)
                                                self.stack.pop()

                                            if closeP < openP:
                                                self.stack.append(")")
                                                self.bkt(openP=openP, closeP=closeP + 1, n=n)
                                                self.stack.pop()

                                        def generateParenthesis(self, n: int) -> List[str]:
                                            self.bkt(openP=0, closeP=0, n=n)
                                            return self.sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/daily-temperatures/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >739. Daily Temperatures</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def dailyTemperatures(self, temp: List[int]) -> List[int]:
                                            ans = [0] * len(temp)
                                            st = []

                                            for i in range(0, len(temp)):
                                                while len(st) > 0 and temp[st[-1]] < temp[i]:
                                                    ans[st[-1]] = i - st[-1]
                                                    st.pop()

                                                st.append(i)

                                            return ans
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/car-fleet/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >853. Car Fleet</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
                                            pair = [[p, s] for p, s in zip(position, speed)]
                                            st = []


                                            for p, s in sorted(pair)[::-1]:
                                                st.append((target - p) / s)
                                                if len(st) >= 2 and st[-1] <= st[-2]:
                                                    st.pop()

                                            return len(st)

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >84. Largest Rectangle in Histogram</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def largestRectangleArea(self, heights: List[int]) -> int:
                                            maxArea = 0
                                            st = []

                                            for i, h in enumerate(heights):
                                                start = i 
                                                while len(st) > 0 and st[-1][1] > h:
                                                    index , height = st.pop()
                                                    maxArea = max(maxArea, height * (i - index))
                                                    start = index

                                                st.append((start, h))

                                            for i, h in st:
                                                maxArea = max(maxArea, h * (len(heights) - i))

                                            return maxArea

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/valid-palindrome/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >125. Valid Palindrome</a
                                >
                                <pre>
                                    class Solution:
                                    def isPalindrome(self, s: str) -> bool:
                                        new_s = ""
                                        for c in s:
                                            c = c.lower()
                                            if c >= 'a' and c <= 'z' or c >= '0' and c <= '9':
                                                new_s += c 


                                        i = 0 
                                        j = len(new_s) - 1
                                        while i < j :
                                            if new_s[i] != new_s[j]:
                                                return False

                                            i += 1
                                            j -= 1

                                        return True 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >167. Two Sum II - Input Array Is Sorted</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def twoSum(self, numbers: List[int], target: int) -> List[int]:
                                            i = 0
                                            j = len(numbers) - 1

                                            while i < j:
                                                s = numbers[i] + numbers[j]
                                                if s == target:
                                                    return [i + 1, j + 1]

                                                elif s < target:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return []
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/3sum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >15. 3Sum</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def __init__(self):
                                            self.sol = []

                                        def twoSum(self, nums: List[int], target: int, k: int,i : int, j: int ) -> List[int]:
                                            while i < j:
                                                s = nums[i] + nums[j]
                                                if s < target or i == k:
                                                    i += 1
                                                elif s > target or j == k:
                                                    j -= 1
                                                else:
                                                    cand = [nums[i], nums[j], nums[k]]
                                                    self.sol.append(cand)
                                                    i += 1
                                                    while nums[i] == nums[i - 1] and i < j:
                                                        i += 1

                                            return []

                                        def threeSum(self, nums: List[int]) -> List[List[int]]:
                                            nums.sort()

                                            for k in range(0, len(nums) - 2):
                                                if k > 0 and nums[k] == nums[k - 1]:
                                                    continue
                                                print(nums[k])
                                                self.twoSum(nums,(nums[k] * -1), k,  k + 1,len(nums) - 1)

                                            return self.sol
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/container-with-most-water/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >11. Container With Most Water</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def maxArea(self, height: List[int]) -> int:
                                            max_area = -1
                                            i = 0
                                            j = len(height) - 1
                                            while i < j :
                                                c_area = min(height[i], height[j]) * (j - i)
                                                if c_area > max_area or max_area == -1:
                                                    max_area = c_area

                                                if height[i] < height[j]:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return max_area

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/trapping-rain-water/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >42. Trapping Rain Water</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def trap(self, h: List[int]) -> int:
                                            diff = [0] * len(h)
                                            maxim = 0

                                            for i in range(0, len(h)):
                                                if maxim < h[i]:
                                                    maxim = h[i]
                                                    diff[i] = 0
                                                else:
                                                    diff[i] = maxim - h[i]

                                            w = 0
                                            maxim = 0

                                            for i in range(len(h) - 1, -1, -1):
                                                if maxim < h[i]:
                                                    maxim = h[i]
                                                else:
                                                    diff[i] = min(diff[i], maxim - h[i])
                                                    w += diff[i]

                                            return w
                                </pre>
                                Better approach (Two Pointers)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def trap(self, h: List[int]) -> int:
                                            i = 0
                                            j = len(h) - 1
                                            w = 0
                                            maxL = 0
                                            maxR = 0

                                            while i < j:
                                                if maxL < h[i]:
                                                    maxL = h[i]

                                                if maxR < h[j]:
                                                    maxR = h[j]

                                                maxMin = min(maxL, maxR)

                                                if maxMin > h[i]:
                                                    w += maxMin - h[i]

                                                if maxMin > h[j]:
                                                    w += maxMin - h[j]

                                                if maxL < maxR:
                                                    i += 1
                                                else:
                                                    j -= 1

                                            return w

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >121. Best Time to Buy and Sell Stock</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def maxProfit(self, p: List[int]) -> int:
                                            i = 0
                                            j = 1
                                            max_profit = 0

                                            while j < len(p):
                                                while p[j] >= p[i]: 
                                                    if max_profit < p[j] - p[i]:
                                                        max_profit = p[j] - p[i]
                                                    j += 1

                                                    if j == len(p):
                                                        break
                                                i = j 
                                                j = i + 1

                                            return max_profit
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >3. Longest Substring Without Repeating
                                    Characters</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def lengthOfLongestSubstring(self, s: str) -> int:
                                            hash_table = {}
                                            i = 0
                                            j = 0
                                            l_s = 0

                                            while j < len(s):
                                            
                                                if s[j] not in hash_table.keys():
                                                    hash_table[s[j]] = j
                                                else:
                                                    i = max(i, hash_table[s[j]] + 1)
                                                    hash_table[s[j]] = j

                                                l_s = max(l_s, j - i + 1)
                                                j += 1

                                            return l_s

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/longest-repeating-character-replacement/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >424. Longest Repeating Character
                                    Replacement</a
                                >
                                <pre>
                                    class Solution:
                                    def characterReplacement(self, s: str, k: int) -> int:
                                        i = 0
                                        j = 0
                                        max_f = 0
                                        longest = 0
                                        hash_t = {}
                                        while j < len(s):
                                            if s[j] not in hash_t:
                                                hash_t[s[j]] = 1
                                                
                                            else:
                                                hash_t[s[j]] += 1

                                            max_f = max(max_f, hash_t[s[j]])

                                            if (j - i + 1) - max_f <= k:
                                                longest = max(longest, (j - i + 1))
                                            else:
                                                hash_t[s[i]] -= 1
                                                i += 1

                                            j += 1

                                        return longest
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/permutation-in-string/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >567. Permutation in String</a
                                >
                                <pre>
                                from typing import List
                                class Solution:
                                    def checkInclusion(self, s1: str, s2: str) -> bool:
                                        if len(s2) < len(s1):
                                            return False
                                        hash_s1 = {}
                                        hash_s2 = {}

                                        for k in range(ord('a'), ord('z') + 1):
                                            c = chr(k)
                                            hash_s1[c] = 0
                                            hash_s2[c] = 0


                                        for c in s1:
                                            hash_s1[c] += 1

                                        i = 0
                                        j = len(s1) -  1

                                        for x in range(i, j):
                                            hash_s2[s2[x]] += 1


                                        while j < len(s2):
                                            hash_s2[s2[j]] += 1

                                            ok = True

                                            for k in range(ord('a'), ord('z') + 1):
                                                c = chr(k)

                                                if (c in hash_s1) != (c in hash_s2):
                                                    ok = False

                                                if (c in hash_s1 ) and ( c in hash_s2):
                                                    if hash_s1[c] != hash_s2[c]:
                                                        ok = False

                                            if ok == True:
                                                return True

                                            hash_s2[s2[i]] -= 1

                                            i += 1
                                            j += 1

                                        return False

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/minimum-window-substring/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >76. Minimum Window Substring</a
                                >
                                <pre>
                                    class Solution:
                                        def minWindow(self, s: str, t: str) -> str:
                                            if t == "":
                                                return ""
                                    
                                            l = 0
                                            r = 0
                                    
                                            hash_t, hash_s = {}, {}
                                    
                                            min_seq = float("infinity")
                                    
                                            sl, sr = [-1, -1]
                                    
                                    
                                            for c in t:
                                                hash_t[c] = 1 + hash_t.get(c, 0)
                                    
                                            have = 0
                                            need = len(hash_t)
                                    
                                            while r < len(s):
                                                hash_s[s[r]] = hash_s.get(s[r], 0) + 1
                                    
                                                if s[r] in hash_t and hash_s[s[r]] == hash_t[s[r]]:
                                                    have += 1
                                    
                                                while have == need:
                                                    if min_seq > (r - l + 1):
                                                        min_seq = r - l + 1
                                                        sl = l
                                                        sr = r 
                                    
                                                    hash_s[s[l]] -= 1 
                                    
                                                    if s[l] in hash_t and hash_s[s[l]] < hash_t[s[l]]:
                                                        have -= 1
                                    
                                                    l += 1
                                                r += 1
                                            return s[sl : sr + 1] if min_seq != float("infinity") else ""
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/sliding-window-maximum/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >239. Sliding Window Maximum</a
                                >
                                <pre>
                                    from collections import deque
                                    from typing import List


                                    class Solution:
                                        def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
                                            sol = []
                                            dq = deque()

                                            l = 0
                                            r = l + k - 1

                                            for x in range(r + 1):
                                                while len(dq) > 0 and nums[x] > dq[-1]:
                                                    dq.pop()

                                                dq.append(nums[x])
                                            
                                            sol.append(dq[0])

                                            while r < (len(nums) - 1):
                                                if nums[l] == dq[0]:
                                                    dq.popleft()

                                                l += 1

                                                r += 1

                                                while len(dq) > 0 and nums[r] > dq[-1]:
                                                    dq.pop()
                                                dq.append(nums[r])
                                                sol.append(dq[0])

                                            return sol 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/binary-search/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >704. Binary Search</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def search(self, nums: List[int], target: int) -> int:
                                            l = 0
                                            r = len(nums) - 1

                                            while l <= r:
                                                mid = (l + r) // 2 
                                                if nums[mid] == target:
                                                    return mid
                                                elif nums[mid] > target:
                                                    r = mid - 1
                                                else:
                                                    l = mid + 1 

                                            return -1
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/search-a-2d-matrix/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >74. Search a 2D Matrix</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
                                            arr = []

                                            for r in range(len(matrix)):
                                                for c in range(len(matrix[0])):
                                                    arr.append(matrix[r][c])

                                            l = 0 
                                            r = len(arr) - 1

                                            while l <= r:
                                                mid = (l + r) // 2
                                                if arr[mid] == target:
                                                    return True 
                                                elif target > arr[mid]:
                                                    l = mid + 1
                                                else:
                                                    r = mid - 1

                                            return False 
                                </pre>
                                Better approach (No Extra Space)
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
                                            ROWS, COLS = len(matrix), len(matrix[0])

                                            bot, top = 0, ROWS - 1 

                                            while bot <= top:
                                                m_row = (bot + top) // 2 
                                                if target > matrix[m_row][-1]:
                                                    bot = m_row + 1 
                                                elif target < matrix[m_row][0]:
                                                    top = m_row - 1 
                                                else:
                                                    break

                                            if bot > top:
                                                return False 

                                            row = (top + bot) // 2 
                                            print(row)
                                            l, r = 0, COLS - 1 

                                            while l <= r: 
                                                m = (l + r) // 2 
                                                print(m)
                                                if target > matrix[row][m]:
                                                    l = m + 1
                                                elif target < matrix[row][m]:
                                                    r = m - 1
                                                else :
                                                    return True 
                                            return False 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/koko-eating-bananas/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >875. Koko Eating Bananas</a
                                >
                                <pre>
                                    import math 
                                    from typing import List
                                    class Solution:
                                        def minEatingSpeed(self, piles: List[int], h: int) -> int:
                                            l = 1
                                            r = max(piles)

                                            sol = float("infinity")

                                            while l <= r:
                                                k = (l + r) // 2
                                                print(k)
                                                h_e = 0

                                                for i in range(len(piles)):
                                                    h_e += math.ceil(piles[i] / k)

                                                if h_e <=  h:
                                                    sol = k 
                                                    r = k - 1
                                                else:
                                                    l = k + 1

                                            return sol

                                </pre>
                                <a
                                    href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >153. Find Minimum in Rotated Sorted
                                    Array</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def findMin(self, nums: List[int]) -> int:
                                            res = nums[0]

                                            l, r = 0, len(nums) - 1

                                            while l <= r:
                                                if nums[l] < nums[r]:
                                                    res = min(res, nums[l])
                                                    break

                                                m = (l + r) // 2
                                                res = min(res, nums[m])

                                                if nums[m] >= nums[l]:
                                                    l = m + 1
                                                else:
                                                    r = m - 1
                                            return res 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >33. Search in Rotated Sorted Array</a
                                >
                                <pre>
                                    from typing import List

                                    class Solution:
                                        def search(self, nums: List[int], target: int) -> int:
                                            l, r = 0, len(nums) - 1

                                            while l <= r:
                                                m = (l + r) // 2
                                                if target == nums[m]:
                                                    return m

                                                if nums[l] <= nums[m]:
                                                    if target > nums[m] or target < nums[l]:
                                                        l = m + 1 
                                                    else:
                                                        r = m - 1 
                                                else:
                                                    if target < nums[m] or target > nums[r]:
                                                        r = m - 1
                                                    else:
                                                        l = m + 1

                                            return -1 
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/time-based-key-value-store/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >981. Time Based Key-Value Store</a
                                >
                                <pre>
                                    class TimeMap:

                                    def __init__(self):
                                        self.hash = {}

                                    def set(self, key: str, value: str, timestamp: int) -> None:
                                        if key not in self.hash:
                                            self.hash[key] = { "v" : [], "t" : []}

                                        self.hash[key]["v"].append(value)
                                        self.hash[key]["t"].append(timestamp)

                                    def get(self, key: str, timestamp: int) -> str:
                                        if key not in self.hash:
                                            return ""
                                        arr = self.hash[key]["t"]

                                        l , r = 0, len(arr) - 1 
                                        index = float("infinity")
                                        while l <= r:
                                            m = (l + r) // 2 
                                            if arr[m] <= timestamp:
                                                index = m
                                                if arr[m] == timestamp:
                                                    break
                                                else:
                                                    l = m + 1 
                                            else:
                                                r = m - 1
                                        if index != float("infinity"):
                                            return self.hash[key]["v"][index]
                                        return ""
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >4. Median of Two Sorted Arrays</a
                                >
                                <pre>
                                    from typing import List
                                    class Solution:
                                        def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
                                            A, B = nums1, nums2
                                            total = len(nums1) + len(nums2)
                                            half = total // 2

                                            if len(B) < len(A):
                                                A, B = B, A

                                            l, r = 0, len(A) - 1
                                            while True:
                                                i = (l + r) // 2  
                                                j = half - i - 2  

                                                Aleft = A[i] if i >= 0 else float("-infinity")
                                                Aright = A[i + 1] if (i + 1) < len(A) else float("infinity")
                                                Bleft = B[j] if j >= 0 else float("-infinity")
                                                Bright = B[j + 1] if (j + 1) < len(B) else float("infinity")

                                                if Aleft <= Bright and Bleft <= Aright:
                                                    if total % 2:
                                                        return min(Aright, Bright)
                                                    return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
                                                elif Aleft > Bright:
                                                    r = i - 1
                                                else:
                                                    l = i + 1
                                </pre>
                                <a
                                    href="https://leetcode.com/problems/reverse-linked-list/description/"
                                    target="_blank"
                                    style="text-decoration: none"
                                    >206. Reverse Linked List</a
                                >
                                <br />
                                ITERATIVE APPROACH:
                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
                                                current = head;
                                                prev = None;
                                                if current == None:
                                                    return current
                                                while current.next != None:
                                                    next_node = current.next
                                                    current.next = prev
                                                    prev = current
                                                    current = next_node
                                                current.next = prev
                                                return current
                                    </code>
                                </pre>
                                RECURSIVE APPROACH:

                                <pre>
                                    <code>
                                        # Definition for singly-linked list.
                                        # class ListNode:
                                        #     def __init__(self, val=0, next=None):
                                        #         self.val = val
                                        #         self.next = next
                                        class Solution:
                                            def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
                                                def recursive(ll, rl):
                                                    if not ll:
                                                        return rl
                                                    return recursive(ll.next, ListNode(ll.val, rl))
                                                
                                                return recursive(head, None)
                                    </code>
                                </pre>
                            </b>
                        </p>
                    </ul>
                </div>
            </div>
        </main>
    </body>
    <footer>
        <nav class="navbar bg-body-tertiary sticky-bottom">
            <div class="container-fluid d-flex justify-content-center">
                <p>
                    <b>
                        <i>Better Than Yesterday</i>
                    </b>
                </p>
            </div>
        </nav>
    </footer>
</html>
